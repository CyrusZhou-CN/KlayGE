From 195a9476c8f80ed4d54075e7424790997d182f4e Mon Sep 17 00:00:00 2001
From: Minmin Gong <gongminmin@msn.com>
Date: Sun, 20 Jan 2019 20:21:33 -0800
Subject: [PATCH 3/3] Fix for UWP

---
 Modules/faulthandler.c |  2 +-
 Modules/posixmodule.c  | 34 ++++++++++++++++++++++++++++++----
 PC/pyconfig.h          | 21 +++++++++++++++++++++
 Python/dynload_win.c   | 12 ++++++++++++
 Python/fileutils.c     | 13 +++++++++++++
 Python/sysmodule.c     |  2 ++
 6 files changed, 79 insertions(+), 5 deletions(-)

diff --git a/Modules/faulthandler.c b/Modules/faulthandler.c
index 520b7b603e..37afd54f54 100644
--- a/Modules/faulthandler.c
+++ b/Modules/faulthandler.c
@@ -1006,7 +1006,7 @@ faulthandler_unregister_py(PyObject *self, PyObject *args)
 static void
 faulthandler_suppress_crash_report(void)
 {
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_WINDOWS_STORE)
     UINT mode;
 
     /* Configure Windows to not display the Windows Error Reporting dialog */
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index c6410fceeb..a037e7b329 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -18,7 +18,9 @@
 #  include <pathcch.h>
 #  include <lmcons.h>             // UNLEN
 #  include "osdefs.h"             // SEP
-#  define HAVE_SYMLINK
+#  ifndef MS_WINDOWS_STORE
+#    define HAVE_SYMLINK
+#  endif
 #endif
 
 #ifdef __VXWORKS__
@@ -339,8 +341,10 @@ corresponding Unix manual entries for more information on calls.");
 #else
 #  if defined(_MSC_VER) || defined(__MINGW32__)
      /* Microsoft compiler or MinGW */
-#    define HAVE_GETPPID    1
-#    define HAVE_GETLOGIN   1
+#    ifndef MS_WINDOWS_STORE
+#      define HAVE_GETPPID    1
+#      define HAVE_GETLOGIN   1
+#    endif  /* ! MS_WINDOWS_STORE */
 #    define HAVE_SPAWNV     1
 #    define HAVE_EXECV      1
 #    define HAVE_WSPAWNV    1
@@ -13544,6 +13548,10 @@ static int
 os_get_handle_inheritable_impl(PyObject *module, intptr_t handle)
 /*[clinic end generated code: output=36be5afca6ea84d8 input=cfe99f9c05c70ad1]*/
 {
+#ifdef MS_WINDOWS_STORE
+    /* No subprocesses on UWP */
+    return 0;
+#else
     DWORD flags;
 
     if (!GetHandleInformation((HANDLE)handle, &flags)) {
@@ -13552,6 +13560,7 @@ os_get_handle_inheritable_impl(PyObject *module, intptr_t handle)
     }
 
     return flags & HANDLE_FLAG_INHERIT;
+#endif
 }
 
 
@@ -13569,12 +13578,17 @@ os_set_handle_inheritable_impl(PyObject *module, intptr_t handle,
                                int inheritable)
 /*[clinic end generated code: output=021d74fe6c96baa3 input=7a7641390d8364fc]*/
 {
+#ifdef MS_WINDOWS_STORE
+    PyErr_SetString(PyExc_NotImplementedError, "No subprocesses on UWP");
+    return NULL;
+#else
     DWORD flags = inheritable ? HANDLE_FLAG_INHERIT : 0;
     if (!SetHandleInformation((HANDLE)handle, HANDLE_FLAG_INHERIT, flags)) {
         PyErr_SetFromWindowsErr(0);
         return NULL;
     }
     Py_RETURN_NONE;
+#endif
 }
 #endif /* MS_WINDOWS */
 
@@ -14726,8 +14740,10 @@ os_getrandom_impl(PyObject *module, Py_ssize_t size, int flags)
  * on win32
  */
 
+#ifndef MS_WINDOWS_STORE
 typedef DLL_DIRECTORY_COOKIE (WINAPI *PAddDllDirectory)(PCWSTR newDirectory);
 typedef BOOL (WINAPI *PRemoveDllDirectory)(DLL_DIRECTORY_COOKIE cookie);
+#endif
 
 /*[clinic input]
 os._add_dll_directory
@@ -14748,6 +14764,10 @@ static PyObject *
 os__add_dll_directory_impl(PyObject *module, path_t *path)
 /*[clinic end generated code: output=80b025daebb5d683 input=1de3e6c13a5808c8]*/
 {
+#ifdef MS_WINDOWS_STORE
+    PyErr_SetString(PyExc_NotImplementedError, "No dll directory support in UWP");
+    return PyErr_SetExcFromWindowsErrWithFilenameObject(PyExc_NotImplementedError, 0, NULL);
+#else
     HMODULE hKernel32;
     PAddDllDirectory AddDllDirectory;
     DLL_DIRECTORY_COOKIE cookie = 0;
@@ -14775,6 +14795,7 @@ os__add_dll_directory_impl(PyObject *module, path_t *path)
     }
 
     return PyCapsule_New(cookie, "DLL directory cookie", NULL);
+#endif
 }
 
 /*[clinic input]
@@ -14793,6 +14814,10 @@ static PyObject *
 os__remove_dll_directory_impl(PyObject *module, PyObject *cookie)
 /*[clinic end generated code: output=594350433ae535bc input=c1d16a7e7d9dc5dc]*/
 {
+#ifdef MS_WINDOWS_STORE
+    PyErr_SetString(PyExc_NotImplementedError, "No dll directory support in UWP");
+    return PyErr_SetExcFromWindowsErrWithFilenameObject(PyExc_NotImplementedError, 0, NULL);
+#else
     HMODULE hKernel32;
     PRemoveDllDirectory RemoveDllDirectory;
     DLL_DIRECTORY_COOKIE cookieValue;
@@ -14829,6 +14854,7 @@ os__remove_dll_directory_impl(PyObject *module, PyObject *cookie)
     }
 
     Py_RETURN_NONE;
+#endif
 }
 
 #endif
@@ -15659,7 +15685,7 @@ all_ins(PyObject *m)
     if (PyModule_AddIntConstant(m, "_COPYFILE_XATTR", COPYFILE_XATTR)) return -1;
 #endif
 
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_WINDOWS_STORE)
     if (PyModule_AddIntConstant(m, "_LOAD_LIBRARY_SEARCH_DEFAULT_DIRS", LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)) return -1;
     if (PyModule_AddIntConstant(m, "_LOAD_LIBRARY_SEARCH_APPLICATION_DIR", LOAD_LIBRARY_SEARCH_APPLICATION_DIR)) return -1;
     if (PyModule_AddIntConstant(m, "_LOAD_LIBRARY_SEARCH_SYSTEM32", LOAD_LIBRARY_SEARCH_SYSTEM32)) return -1;
diff --git a/PC/pyconfig.h b/PC/pyconfig.h
index 959b851ddc..606deccf8a 100644
--- a/PC/pyconfig.h
+++ b/PC/pyconfig.h
@@ -14,6 +14,8 @@ the following #defines
 MS_WIN64 - Code specific to the MS Win64 API
 MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
 MS_WINDOWS - Code specific to Windows, but all versions.
+MS_WINDOWS_DESKTOP - Code specific to the MS Windows desktop API
+MS_WINDOWS_STORE - Code specific to the MS Windows store (UWP) API
 Py_ENABLE_SHARED - Code if the Python core is built as a DLL.
 
 Also note that neither "_M_IX86" or "_MSC_VER" should be used for
@@ -48,6 +50,21 @@ WIN32 is still required for the locale module.
 #define _CRT_NONSTDC_NO_DEPRECATE 1
 #endif
 
+#if (_WIN32_WINNT >= 0x0A00 /* _WIN32_WINNT_WIN8 */)
+#  include <winapifamily.h>
+#  if defined(WINAPI_FAMILY)
+#    if WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP
+#      define MS_WINDOWS_DESKTOP
+#    else
+#      define MS_WINDOWS_STORE
+#    endif
+#  else
+#    define MS_WINDOWS_DESKTOP
+#  endif
+#else
+#  define MS_WINDOWS_DESKTOP
+#endif
+
 #define HAVE_IO_H
 #define HAVE_SYS_UTIME_H
 #define HAVE_TEMPNAM
@@ -497,6 +514,10 @@ Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
 /* Define if you have getpid.  */
 #define HAVE_GETPID
 
+#ifdef MS_WINDOWS_STORE
+#define getpid GetCurrentProcessId
+#endif
+
 /* Define if you have gettimeofday.  */
 /* #undef HAVE_GETTIMEOFDAY */
 
diff --git a/Python/dynload_win.c b/Python/dynload_win.c
index 1a8582734e..937562e5ec 100644
--- a/Python/dynload_win.c
+++ b/Python/dynload_win.c
@@ -173,6 +173,9 @@ extern HMODULE PyWin_DLLhModule;
 int
 _Py_CheckPython3(void)
 {
+#ifdef MS_WINDOWS_STORE
+    return 0;
+#else
     static int python3_checked = 0;
     static HANDLE hPython3;
     #define MAXPATHLEN 512
@@ -215,6 +218,7 @@ _Py_CheckPython3(void)
     }
     return hPython3 != NULL;
     #undef MAXPATHLEN
+#endif
 }
 
 dl_funcptr _PyImport_FindSharedFuncptrWindows(const char *prefix,
@@ -241,23 +245,31 @@ dl_funcptr _PyImport_FindSharedFuncptrWindows(const char *prefix,
         unsigned int old_mode;
 
         /* Don't display a message box when Python can't load a DLL */
+#ifndef MS_WINDOWS_STORE
         old_mode = SetErrorMode(SEM_FAILCRITICALERRORS);
+#endif
 
         /* bpo-36085: We use LoadLibraryEx with restricted search paths
            to avoid DLL preloading attacks and enable use of the
            AddDllDirectory function. We add SEARCH_DLL_LOAD_DIR to
            ensure DLLs adjacent to the PYD are preferred. */
         Py_BEGIN_ALLOW_THREADS
+#ifdef MS_WINDOWS_STORE
+        hDLL = LoadPackagedLibrary(wpathname, 0);
+#else
         hDLL = LoadLibraryExW(wpathname, NULL,
                               LOAD_LIBRARY_SEARCH_DEFAULT_DIRS |
                               LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR);
+#endif
         Py_END_ALLOW_THREADS
 #if !USE_UNICODE_WCHAR_CACHE
         PyMem_Free(wpathname);
 #endif /* USE_UNICODE_WCHAR_CACHE */
 
         /* restore old error mode settings */
+#ifndef MS_WINDOWS_STORE
         SetErrorMode(old_mode);
+#endif
 
         if (hDLL==NULL){
             PyObject *message;
diff --git a/Python/fileutils.c b/Python/fileutils.c
index 24341dda27..cb0382f561 100644
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -1284,6 +1284,9 @@ static int
 get_inheritable(int fd, int raise)
 {
 #ifdef MS_WINDOWS
+#ifdef MS_WINDOWS_STORE
+    return 0;
+#else
     HANDLE handle;
     DWORD flags;
 
@@ -1301,6 +1304,7 @@ get_inheritable(int fd, int raise)
     }
 
     return (flags & HANDLE_FLAG_INHERIT);
+#endif
 #else
     int flags;
 
@@ -1329,8 +1333,10 @@ static int
 set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
 {
 #ifdef MS_WINDOWS
+#ifndef MS_WINDOWS_STORE
     HANDLE handle;
     DWORD flags;
+#endif
 #else
 #if defined(HAVE_SYS_IOCTL_H) && defined(FIOCLEX) && defined(FIONCLEX)
     static int ioctl_works = -1;
@@ -1358,6 +1364,12 @@ set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
     }
 
 #ifdef MS_WINDOWS
+#ifdef MS_WINDOWS_STORE
+    if (!inheritable)
+        return 0;
+    PyErr_SetString(PyExc_NotImplementedError, "set_inheritable is not implemented on UWP");
+    return -1;
+#else
     handle = _Py_get_osfhandle_noraise(fd);
     if (handle == INVALID_HANDLE_VALUE) {
         if (raise)
@@ -1382,6 +1394,7 @@ set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
     }
 #undef CONSOLE_PSEUDOHANDLE
     return 0;
+#endif
 
 #else
 
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index d0941e8cfe..e8764d0457 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -1491,6 +1491,7 @@ sys_getwindowsversion_impl(PyObject *module)
     realMinor = ver.dwMinorVersion;
     realBuild = ver.dwBuildNumber;
 
+#ifndef MS_WINDOWS_STORE
     // GetVersion will lie if we are running in a compatibility mode.
     // We need to read the version info from a system file resource
     // to accurately identify the OS version. If we fail for any reason,
@@ -1512,6 +1513,7 @@ sys_getwindowsversion_impl(PyObject *module)
         }
         PyMem_RawFree(verblock);
     }
+#endif
     PyStructSequence_SET_ITEM(version, pos++, Py_BuildValue("(kkk)",
         realMajor,
         realMinor,
-- 
2.43.0.windows.1

