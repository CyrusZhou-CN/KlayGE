From b1c1b375291ffa8e1a973c766c8c7237d96072a2 Mon Sep 17 00:00:00 2001
From: Minmin Gong <gongminmin@msn.com>
Date: Sun, 20 Jan 2019 20:21:33 -0800
Subject: [PATCH 3/3] Fix for UWP

---
 Modules/faulthandler.c |  2 +-
 Modules/posixmodule.c  | 34 ++++++++++++++++++++++++++++++----
 PC/getpathp.c          |  4 ++++
 PC/pyconfig.h          | 21 +++++++++++++++++++++
 Python/dynload_win.c   |  8 ++++++++
 Python/fileutils.c     | 13 +++++++++++++
 Python/sysmodule.c     |  2 ++
 7 files changed, 79 insertions(+), 5 deletions(-)

diff --git a/Modules/faulthandler.c b/Modules/faulthandler.c
index 8d2221cfd8..d2d34e8fca 100644
--- a/Modules/faulthandler.c
+++ b/Modules/faulthandler.c
@@ -1023,7 +1023,7 @@ faulthandler_unregister_py(PyObject *self, PyObject *args)
 static void
 faulthandler_suppress_crash_report(void)
 {
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_WINDOWS_STORE)
     UINT mode;
 
     /* Configure Windows to not display the Windows Error Reporting dialog */
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index 23a05529aa..e855dc3dbf 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -23,7 +23,9 @@
 #  include <pathcch.h>
 #  include <lmcons.h>             // UNLEN
 #  include "osdefs.h"             // SEP
-#  define HAVE_SYMLINK
+#  ifndef MS_WINDOWS_STORE
+#    define HAVE_SYMLINK
+#  endif
 #endif
 
 #ifdef __VXWORKS__
@@ -312,8 +314,10 @@ corresponding Unix manual entries for more information on calls.");
 #else
 #  if defined(_MSC_VER) || defined(__MINGW32__)
      /* Microsoft compiler or MinGW */
-#    define HAVE_GETPPID    1
-#    define HAVE_GETLOGIN   1
+#    ifndef MS_WINDOWS_STORE
+#      define HAVE_GETPPID    1
+#      define HAVE_GETLOGIN   1
+#    endif  /* ! MS_WINDOWS_STORE */
 #    define HAVE_SPAWNV     1
 #    define HAVE_EXECV      1
 #    define HAVE_WSPAWNV    1
@@ -13355,6 +13359,10 @@ static int
 os_get_handle_inheritable_impl(PyObject *module, intptr_t handle)
 /*[clinic end generated code: output=36be5afca6ea84d8 input=cfe99f9c05c70ad1]*/
 {
+#ifdef MS_WINDOWS_STORE
+    /* No subprocesses on UWP */
+    return 0;
+#else
     DWORD flags;
 
     if (!GetHandleInformation((HANDLE)handle, &flags)) {
@@ -13363,6 +13371,7 @@ os_get_handle_inheritable_impl(PyObject *module, intptr_t handle)
     }
 
     return flags & HANDLE_FLAG_INHERIT;
+#endif
 }
 
 
@@ -13380,12 +13389,17 @@ os_set_handle_inheritable_impl(PyObject *module, intptr_t handle,
                                int inheritable)
 /*[clinic end generated code: output=021d74fe6c96baa3 input=7a7641390d8364fc]*/
 {
+#ifdef MS_WINDOWS_STORE
+    PyErr_SetString(PyExc_NotImplementedError, "No subprocesses on UWP");
+    return NULL;
+#else
     DWORD flags = inheritable ? HANDLE_FLAG_INHERIT : 0;
     if (!SetHandleInformation((HANDLE)handle, HANDLE_FLAG_INHERIT, flags)) {
         PyErr_SetFromWindowsErr(0);
         return NULL;
     }
     Py_RETURN_NONE;
+#endif
 }
 #endif /* MS_WINDOWS */
 
@@ -14520,8 +14534,10 @@ os_getrandom_impl(PyObject *module, Py_ssize_t size, int flags)
  * on win32
  */
 
+#ifndef MS_WINDOWS_STORE
 typedef DLL_DIRECTORY_COOKIE (WINAPI *PAddDllDirectory)(PCWSTR newDirectory);
 typedef BOOL (WINAPI *PRemoveDllDirectory)(DLL_DIRECTORY_COOKIE cookie);
+#endif
 
 /*[clinic input]
 os._add_dll_directory
@@ -14542,6 +14558,10 @@ static PyObject *
 os__add_dll_directory_impl(PyObject *module, path_t *path)
 /*[clinic end generated code: output=80b025daebb5d683 input=1de3e6c13a5808c8]*/
 {
+#ifdef MS_WINDOWS_STORE
+    PyErr_SetString(PyExc_NotImplementedError, "No dll directory support in UWP");
+    return PyErr_SetExcFromWindowsErrWithFilenameObject(PyExc_NotImplementedError, 0, NULL);
+#else
     HMODULE hKernel32;
     PAddDllDirectory AddDllDirectory;
     DLL_DIRECTORY_COOKIE cookie = 0;
@@ -14569,6 +14589,7 @@ os__add_dll_directory_impl(PyObject *module, path_t *path)
     }
 
     return PyCapsule_New(cookie, "DLL directory cookie", NULL);
+#endif
 }
 
 /*[clinic input]
@@ -14587,6 +14608,10 @@ static PyObject *
 os__remove_dll_directory_impl(PyObject *module, PyObject *cookie)
 /*[clinic end generated code: output=594350433ae535bc input=c1d16a7e7d9dc5dc]*/
 {
+#ifdef MS_WINDOWS_STORE
+    PyErr_SetString(PyExc_NotImplementedError, "No dll directory support in UWP");
+    return PyErr_SetExcFromWindowsErrWithFilenameObject(PyExc_NotImplementedError, 0, NULL);
+#else
     HMODULE hKernel32;
     PRemoveDllDirectory RemoveDllDirectory;
     DLL_DIRECTORY_COOKIE cookieValue;
@@ -14623,6 +14648,7 @@ os__remove_dll_directory_impl(PyObject *module, PyObject *cookie)
     }
 
     Py_RETURN_NONE;
+#endif
 }
 
 #endif
@@ -15444,7 +15470,7 @@ all_ins(PyObject *m)
     if (PyModule_AddIntConstant(m, "_COPYFILE_DATA", COPYFILE_DATA)) return -1;
 #endif
 
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(MS_WINDOWS_STORE)
     if (PyModule_AddIntConstant(m, "_LOAD_LIBRARY_SEARCH_DEFAULT_DIRS", LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)) return -1;
     if (PyModule_AddIntConstant(m, "_LOAD_LIBRARY_SEARCH_APPLICATION_DIR", LOAD_LIBRARY_SEARCH_APPLICATION_DIR)) return -1;
     if (PyModule_AddIntConstant(m, "_LOAD_LIBRARY_SEARCH_SYSTEM32", LOAD_LIBRARY_SEARCH_SYSTEM32)) return -1;
diff --git a/PC/getpathp.c b/PC/getpathp.c
index 7c0eeab5db..97cddf380a 100644
--- a/PC/getpathp.c
+++ b/PC/getpathp.c
@@ -1105,6 +1105,9 @@ static HANDLE hPython3;
 int
 _Py_CheckPython3(void)
 {
+#ifdef MS_WINDOWS_STORE
+    return 0;
+#else
     wchar_t py3path[MAXPATHLEN+1];
     if (python3_checked) {
         return hPython3 != NULL;
@@ -1137,4 +1140,5 @@ _Py_CheckPython3(void)
         hPython3 = LoadLibraryExW(py3path, NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
     }
     return hPython3 != NULL;
+#endif
 }
diff --git a/PC/pyconfig.h b/PC/pyconfig.h
index 103e647ac8..6f3ebe1eea 100644
--- a/PC/pyconfig.h
+++ b/PC/pyconfig.h
@@ -14,6 +14,8 @@ the following #defines
 MS_WIN64 - Code specific to the MS Win64 API
 MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
 MS_WINDOWS - Code specific to Windows, but all versions.
+MS_WINDOWS_DESKTOP - Code specific to the MS Windows desktop API
+MS_WINDOWS_STORE - Code specific to the MS Windows store (UWP) API
 Py_ENABLE_SHARED - Code if the Python core is built as a DLL.
 
 Also note that neither "_M_IX86" or "_MSC_VER" should be used for
@@ -48,6 +50,21 @@ WIN32 is still required for the locale module.
 #define _CRT_NONSTDC_NO_DEPRECATE 1
 #endif
 
+#if (_WIN32_WINNT >= 0x0A00 /* _WIN32_WINNT_WIN8 */)
+#  include <winapifamily.h>
+#  if defined(WINAPI_FAMILY)
+#    if WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP
+#      define MS_WINDOWS_DESKTOP
+#    else
+#      define MS_WINDOWS_STORE
+#    endif
+#  else
+#    define MS_WINDOWS_DESKTOP
+#  endif
+#else
+#  define MS_WINDOWS_DESKTOP
+#endif
+
 #define HAVE_IO_H
 #define HAVE_SYS_UTIME_H
 #define HAVE_TEMPNAM
@@ -501,6 +518,10 @@ Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
 /* Define if you have getpid.  */
 #define HAVE_GETPID
 
+#ifdef MS_WINDOWS_STORE
+#define getpid GetCurrentProcessId
+#endif
+
 /* Define if you have gettimeofday.  */
 /* #undef HAVE_GETTIMEOFDAY */
 
diff --git a/Python/dynload_win.c b/Python/dynload_win.c
index 96faa4b462..7ea8f02212 100644
--- a/Python/dynload_win.c
+++ b/Python/dynload_win.c
@@ -185,23 +185,31 @@ dl_funcptr _PyImport_FindSharedFuncptrWindows(const char *prefix,
         unsigned int old_mode;
 
         /* Don't display a message box when Python can't load a DLL */
+#ifndef MS_WINDOWS_STORE
         old_mode = SetErrorMode(SEM_FAILCRITICALERRORS);
+#endif
 
         /* bpo-36085: We use LoadLibraryEx with restricted search paths
            to avoid DLL preloading attacks and enable use of the
            AddDllDirectory function. We add SEARCH_DLL_LOAD_DIR to
            ensure DLLs adjacent to the PYD are preferred. */
         Py_BEGIN_ALLOW_THREADS
+#ifdef MS_WINDOWS_STORE
+        hDLL = LoadPackagedLibrary(wpathname, 0);
+#else
         hDLL = LoadLibraryExW(wpathname, NULL,
                               LOAD_LIBRARY_SEARCH_DEFAULT_DIRS |
                               LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR);
+#endif
         Py_END_ALLOW_THREADS
 #if !USE_UNICODE_WCHAR_CACHE
         PyMem_Free(wpathname);
 #endif /* USE_UNICODE_WCHAR_CACHE */
 
         /* restore old error mode settings */
+#ifndef MS_WINDOWS_STORE
         SetErrorMode(old_mode);
+#endif
 
         if (hDLL==NULL){
             PyObject *message;
diff --git a/Python/fileutils.c b/Python/fileutils.c
index 3b53baa00e..f2e0fed2a8 100644
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -1260,6 +1260,9 @@ static int
 get_inheritable(int fd, int raise)
 {
 #ifdef MS_WINDOWS
+#ifdef MS_WINDOWS_STORE
+    return 0;
+#else
     HANDLE handle;
     DWORD flags;
 
@@ -1277,6 +1280,7 @@ get_inheritable(int fd, int raise)
     }
 
     return (flags & HANDLE_FLAG_INHERIT);
+#endif
 #else
     int flags;
 
@@ -1305,8 +1309,10 @@ static int
 set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
 {
 #ifdef MS_WINDOWS
+#ifndef MS_WINDOWS_STORE
     HANDLE handle;
     DWORD flags;
+#endif
 #else
 #if defined(HAVE_SYS_IOCTL_H) && defined(FIOCLEX) && defined(FIONCLEX)
     static int ioctl_works = -1;
@@ -1334,6 +1340,12 @@ set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
     }
 
 #ifdef MS_WINDOWS
+#ifdef MS_WINDOWS_STORE
+    if (!inheritable)
+        return 0;
+    PyErr_SetString(PyExc_NotImplementedError, "set_inheritable is not implemented on UWP");
+    return -1;
+#else
     handle = _Py_get_osfhandle_noraise(fd);
     if (handle == INVALID_HANDLE_VALUE) {
         if (raise)
@@ -1358,6 +1370,7 @@ set_inheritable(int fd, int inheritable, int raise, int *atomic_flag_works)
     }
 #undef CONSOLE_PSEUDOHANDLE
     return 0;
+#endif
 
 #else
 
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index e740cf933d..c61642aedc 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -1527,6 +1527,7 @@ sys_getwindowsversion_impl(PyObject *module)
     realMinor = ver.dwMinorVersion;
     realBuild = ver.dwBuildNumber;
 
+#ifndef MS_WINDOWS_STORE
     // GetVersion will lie if we are running in a compatibility mode.
     // We need to read the version info from a system file resource
     // to accurately identify the OS version. If we fail for any reason,
@@ -1548,6 +1549,7 @@ sys_getwindowsversion_impl(PyObject *module)
         }
         PyMem_RawFree(verblock);
     }
+#endif
     PyStructSequence_SET_ITEM(version, pos++, Py_BuildValue("(kkk)",
         realMajor,
         realMinor,
-- 
2.43.0.windows.1

